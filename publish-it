#!/bin/bash
# Copyright (c) 2013 Jean-Baptiste Carr√© <jbc@0x1d.org>.
# Version: git-sha-tag
#
# Publish a whole folder of svg files in exported pdf files
#
# This code is licensed under the GNU General Public License, either
# version 3 of the License, or (at your option) any later version.
#

function is_git_repo {
    # USAGE: is_git_repo <path>
    if [ -d "$1" ]; then
        git_repo_test=$(find "$1" -maxdepth 1 -type d -name .git | wc -l)
        if [[ $git_repo_test -eq 1 ]]; then
            echo "1"
        else
            echo "0"
        fi
    else
        echo "0"
    fi
}

function is_git_annex_repo {
    # USAGE: is_git_annex_repo <path>
    if [[ $(is_git_repo $1) -eq 1 ]]; then
        git_annex_repo_test=$(find "$1"/.git -maxdepth 1 -type d \
            -name annex | wc -l)
        if [[ $git_annex_repo_test -eq 1 ]]; then
            echo "1"
        else
            echo "0"
        fi
    else
        echo "0"
    fi
}


function git_get_sha {
    # USAGE: git_get_sha <repo_path>
    if [[ $(is_git_repo "$1") -eq 1 ]]; then
        git_sha=$(git log -1 --format=format:'%h' --abbrev-commit)
        echo $git_sha
    else
        echo "$1 is not a git repository. Exiting..."
        exit 1
    fi
}

function git_get_date {
    # USAGE: git_get_date <repo_path>
    if [[ $(is_git_repo "$1") -eq 1 ]]; then
        git_date=$(date -d "$(git log -1 --format=format:'%ci' \
            --abbrev-commit)" +%Y-%m-%d)
        echo $git_date
    else
        echo "$1 is not a git repository. Exiting..."
        exit 1
    fi
}
    
function publish_git_repo {
    # USAGE: publish_git_repo <repo_path> <commit>
    
    if [ "$1" == "" ]; then
        repo_path="./"
    else
        repo_path="$1"
    fi
    
    if [ "$2" == "" ]; then
        commit="HEAD"
    else
        commit="$2"
    fi
    
    cur_location=$(pwd)
    cd $repo_path
    
    cur_branch_name=$(git branch | grep "*" | cut -f 2 -d " ")
    git checkout --detach "$2" &> /dev/null
    gitsha=$(git_get_sha "$1")
    gitdate=$(git_get_date "$1")
    echo "git checkout - detached head @$gitsha"
    new_dir_name=$gitdate-$(basename $repo_path)-$gitsha
    
    echo "Preparing the archive..."
    tar -cf /tmp/$new_dir_name.tar --dereference --exclude-vcs \
        --exclude-backups ./ &> /dev/null
    rm -Rf /tmp/$new_dir_name
    mkdir /tmp/$new_dir_name
    tar -C /tmp/$new_dir_name -xf /tmp/$new_dir_name.tar &> /dev/null
    rm -f /tmp/$new_dir_name.tar
    cd /tmp/$new_dir_name
    find . -type d -empty -delete
    rm -f .git*
    cd ..
    tar -czf "$repo_path/../$new_dir_name.tar.gz" "./$new_dir_name" &> /dev/null
    rm -Rf $new_dir_name
    cd $repo_path/../
    echo "Archive ready at $(pwd)/$new_dir_name.tar.gz"
    tar -tzf $(pwd)/$new_dir_name.tar.gz
    cd $repo_path
    git checkout $cur_branch_name
    cd $cur_location
    
}


source="$1"
org_path=$(pwd)


publish_git_repo $1 $2





exit 1

# path where we are when the script is called
orgpath=`pwd`

# initialize options
recursivemode=
commitmode=

# read options
while getopts rc: name; do
    case $name in
        r) recursivemode=1;;
        c) commitmode=1
            commit="$OPTARG";;
        ?) printf "Usage: %s: [-r] [-c commit-hash] file(s)-or-folder-path\n" $0
            exit 2;;
    esac
done

# if the commit-mode is on, revert to the specified commit for export
if [ ! -z "$commitmode" ]; then
    printf 'Option -c "%s" specified\n' "$commit"
else # else take the last file version or commit
    printf "Option -c not specified\n"
fi

# what remains after those arguments should the one or more files
# or folder paths.
shift $(($OPTIND - 1))
paths=$*

# if no path is given, path is the current path
if [ -z "$paths" ]; then
    paths="$orgpath"
fi

# for every given path, export the files
for path in $paths; do
    # test if the given path is a folder path or a file path
    # and affect the folderpath variable
    if [ -d $path ]; then
        # we're in folder mode
        mode="folder"
    else
        # we're in file mode
        mode="file"
    fi
    
    if [ $mode == "folder" ]; then
        # if the recursive-mode is on, find all the SVG files recursively
        cd $path
        if [ ! -z "$recursivemode" ]; then
            filepaths=`find -L -iname "*.svg" -print`
        else # else, find then only in the current folder
            filepaths=`find -L -maxdepth 1 -iname "*.svg" -print`
        fi
        cd $orgpath
    else # file mode
        filepaths=$path
    fi

    for filepath in $filepaths; do
        if [ $mode == "folder" ]; then
            folderpath=$path # not working in every case :-(
        else
            folderpath=`dirname "$filepath"`
        fi
        filename="${filepath##*/}"
        cd $folderpath
        gitdate=`git log -1 --format=format:'%ci' --abbrev-commit "$filename"`
        gitsha=`git log -1 --format=format:'%h' --abbrev-commit "$filename"`
        gitstatus=`git status | grep "$filename" | wc -l`
        lastmod=`stat -c --format=%y "$filename"`

        if [ -z $commitmode]; then
        git show $commit:"$filegitpath" > "/tmp/$file-tmp"
        
        # Test if the file as been modified since the last commit
        if [ $gitstatus -eq 0 ]; then
            # If no, and if the output file does not exist, create the file
            newfilename="${filename%.*}-$gitsha".pdf
            if [ ! -f $newfilename ]; then
                echo "$filename > $newfilename"
                sed "s/git-sha/$gitsha ($gitdate)/g" "$filename" > "/tmp/$filename"
                inkscape -D -A "$newfilename" -f "/tmp/$filename"
            else
                # Else, skip the process
                echo "$newfilename exists: skipping..."
            fi
        else
            # If the file has been modified since the last commit, create the
            # file every time the script is run, but append "dirty"
            newfilename="${filename%.*}-$gitsha-dirty".pdf
            echo "$filename > $newfilename"
            sed "s/git-sha/$gitsha-dirty ($lastmod)/g" "$filename" > "/tmp/$filename"
            inkscape -D -A "$newfilename" -f "/tmp/$filename"
        fi
        rm -f /tmp/$filename
        cd $orgpath
    done
done
cd $orgpath
exit





else # if mode is file
    folderpath=`dirname $path`
    cd $folderpath
    file=$1
    commit=$2
    curlocation=`pwd`
    # Find the root of the current git repository
    while [ ! -d .git ] && [ ! `pwd` = "/" ]; do cd ..; done
    gitrepolocation=`pwd`
    cd $curlocation
    filegitpath=${curlocation#"$gitrepolocation/"}/$file
    git show $commit:"$filegitpath" > "/tmp/$file-tmp"
    gitdate=`git log -1 --format=format:'%ci' --abbrev-commit $commit`
    gitsha=`git log -1 --format=format:'%h' --abbrev-commit $commit`
    filename="${file%.*}-$gitsha".pdf
    echo "$file > $filename"
    sed "s/git-sha/$gitsha ($gitdate)/g" "/tmp/$file-tmp" > "/tmp/$file"
    inkscape -D -A "${file%.*}-$gitsha".pdf -f "/tmp/$file"
    rm -f "/tmp/$file" "/tmp/$file-tmp"
    cd $curpath
fi

# TODO: add help, add arguments parser, add get last version from master.
